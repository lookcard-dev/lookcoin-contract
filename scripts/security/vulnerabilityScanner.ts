import { execSync } from "child_process";
import fs from "fs";
import path from "path";

/**
 * Automated vulnerability scanner using Slither and custom detectors
 */
class VulnerabilityScanner {
    private contractsPath: string;
    private outputPath: string;
    private customDetectors: string[];

    constructor() {
        this.contractsPath = path.join(__dirname, "../../contracts");
        this.outputPath = path.join(__dirname, "../../security-scan-results");
        this.customDetectors = [
            "reentrancy-eth",
            "reentrancy-no-eth",
            "reentrancy-benign",
            "reentrancy-events",
            "reentrancy-unlimited-gas",
            "suicidal",
            "uninitialized-state",
            "uninitialized-storage",
            "arbitrary-send-eth",
            "controlled-delegatecall",
            "delegatecall-loop",
            "msg-value-loop",
            "unchecked-transfer",
            "unchecked-lowlevel",
            "unchecked-send",
            "void-cst",
            "divide-before-multiply",
            "incorrect-equality",
            "locked-ether",
            "mapping-deletion",
            "shadowing-state",
            "tautology",
            "write-after-write",
            "boolean-cst",
            "constant-function-asm",
            "constant-function-state"
        ];
    }

    /**
     * Run Slither security analysis
     */
    async runSlitherAnalysis(): Promise<SlitherResults> {
        console.log("üîç Running Slither analysis...");
        
        const results: SlitherResults = {
            high: [],
            medium: [],
            low: [],
            informational: [],
            optimization: []
        };

        try {
            // Create output directory if it doesn't exist
            if (!fs.existsSync(this.outputPath)) {
                fs.mkdirSync(this.outputPath, { recursive: true });
            }

            // Run Slither with JSON output
            const jsonOutput = path.join(this.outputPath, "slither-report.json");
            const command = `slither . --json ${jsonOutput} --disable-solc-warnings`;
            
            console.log("Executing:", command);
            execSync(command, { 
                cwd: path.join(__dirname, "../../"),
                stdio: "inherit"
            });

            // Parse results
            if (fs.existsSync(jsonOutput)) {
                const slitherData = JSON.parse(fs.readFileSync(jsonOutput, "utf8"));
                
                if (slitherData.results && slitherData.results.detectors) {
                    slitherData.results.detectors.forEach((detector: any) => {
                        const issue: SecurityIssue = {
                            check: detector.check,
                            impact: detector.impact,
                            confidence: detector.confidence,
                            description: detector.description,
                            elements: detector.elements || []
                        };

                        switch (detector.impact) {
                            case "High":
                                results.high.push(issue);
                                break;
                            case "Medium":
                                results.medium.push(issue);
                                break;
                            case "Low":
                                results.low.push(issue);
                                break;
                            case "Informational":
                                results.informational.push(issue);
                                break;
                            case "Optimization":
                                results.optimization.push(issue);
                                break;
                        }
                    });
                }
            }

            console.log("‚úÖ Slither analysis completed");
            return results;

        } catch (error: any) {
            console.error("‚ùå Slither analysis failed:", error.message);
            // Check if Slither is installed
            try {
                execSync("slither --version", { stdio: "ignore" });
            } catch {
                console.error("Slither is not installed. Install it with: pip3 install slither-analyzer");
            }
            throw error;
        }
    }

    /**
     * Run custom vulnerability detection
     */
    async runCustomDetection(): Promise<CustomVulnerabilities> {
        console.log("üîç Running custom vulnerability detection...");
        
        const vulnerabilities: CustomVulnerabilities = {
            unboundedLoops: [],
            externalCalls: [],
            assemblyUsage: [],
            deprecatedFunctions: [],
            suspiciousPatterns: []
        };

        // Scan all Solidity files
        const solidityFiles = this.findSolidityFiles(this.contractsPath);
        
        for (const file of solidityFiles) {
            const content = fs.readFileSync(file, "utf8");
            const relativePath = path.relative(this.contractsPath, file);
            
            // Check for unbounded loops
            const loopMatches = content.match(/for\s*\([^)]*\)\s*{|while\s*\([^)]*\)\s*{/g);
            if (loopMatches) {
                loopMatches.forEach(match => {
                    vulnerabilities.unboundedLoops.push({
                        file: relativePath,
                        pattern: match.trim(),
                        recommendation: "Ensure loop bounds are limited to prevent DoS"
                    });
                });
            }

            // Check for external calls
            const externalCallPatterns = [
                /\.call\(/g,
                /\.delegatecall\(/g,
                /\.staticcall\(/g,
                /\.transfer\(/g,
                /\.send\(/g
            ];

            externalCallPatterns.forEach(pattern => {
                const matches = content.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        vulnerabilities.externalCalls.push({
                            file: relativePath,
                            pattern: match,
                            recommendation: "Ensure external calls are properly handled with checks-effects-interactions pattern"
                        });
                    });
                }
            });

            // Check for assembly usage
            const assemblyMatches = content.match(/assembly\s*{/g);
            if (assemblyMatches) {
                vulnerabilities.assemblyUsage.push({
                    file: relativePath,
                    pattern: "assembly block",
                    recommendation: "Assembly code requires careful review for safety"
                });
            }

            // Check for deprecated functions
            const deprecatedPatterns = [
                { pattern: /suicide\(/g, name: "suicide" },
                { pattern: /sha3\(/g, name: "sha3" },
                { pattern: /callcode\(/g, name: "callcode" },
                { pattern: /throw;/g, name: "throw" }
            ];

            deprecatedPatterns.forEach(({ pattern, name }) => {
                if (pattern.test(content)) {
                    vulnerabilities.deprecatedFunctions.push({
                        file: relativePath,
                        pattern: name,
                        recommendation: `Replace deprecated ${name} with modern equivalent`
                    });
                }
            });

            // Check for suspicious patterns
            const suspiciousPatterns = [
                { pattern: /selfdestruct\(/g, name: "selfdestruct", risk: "Can destroy contract" },
                { pattern: /ecrecover\(/g, name: "ecrecover", risk: "Signature malleability" },
                { pattern: /block\.timestamp/g, name: "block.timestamp", risk: "Can be manipulated by miners" },
                { pattern: /tx\.origin/g, name: "tx.origin", risk: "Phishing vulnerability" }
            ];

            suspiciousPatterns.forEach(({ pattern, name, risk }) => {
                if (pattern.test(content)) {
                    vulnerabilities.suspiciousPatterns.push({
                        file: relativePath,
                        pattern: name,
                        recommendation: `${name} usage detected: ${risk}`
                    });
                }
            });
        }

        console.log("‚úÖ Custom detection completed");
        return vulnerabilities;
    }

    /**
     * Generate comprehensive vulnerability report
     */
    async generateReport(): Promise<void> {
        console.log("üìù Generating vulnerability report...");

        try {
            // Run all scans
            const slitherResults = await this.runSlitherAnalysis();
            const customResults = await this.runCustomDetection();

            // Create report
            const report = `# Vulnerability Scan Report

Generated: ${new Date().toISOString()}

## Slither Analysis Results

### High Severity Issues (${slitherResults.high.length})
${slitherResults.high.map(issue => `
**${issue.check}**
- Impact: ${issue.impact}
- Confidence: ${issue.confidence}
- Description: ${issue.description}
`).join('\n')}

### Medium Severity Issues (${slitherResults.medium.length})
${slitherResults.medium.map(issue => `
**${issue.check}**
- Impact: ${issue.impact}
- Confidence: ${issue.confidence}
- Description: ${issue.description}
`).join('\n')}

### Low Severity Issues (${slitherResults.low.length})
${slitherResults.low.map(issue => `
**${issue.check}**
- Impact: ${issue.impact}
- Confidence: ${issue.confidence}
- Description: ${issue.description}
`).join('\n')}

## Custom Vulnerability Detection

### Unbounded Loops (${customResults.unboundedLoops.length})
${customResults.unboundedLoops.map(v => `- ${v.file}: ${v.pattern}`).join('\n')}

### External Calls (${customResults.externalCalls.length})
${customResults.externalCalls.map(v => `- ${v.file}: ${v.pattern}`).join('\n')}

### Assembly Usage (${customResults.assemblyUsage.length})
${customResults.assemblyUsage.map(v => `- ${v.file}: ${v.pattern}`).join('\n')}

### Deprecated Functions (${customResults.deprecatedFunctions.length})
${customResults.deprecatedFunctions.map(v => `- ${v.file}: ${v.pattern}`).join('\n')}

### Suspicious Patterns (${customResults.suspiciousPatterns.length})
${customResults.suspiciousPatterns.map(v => `- ${v.file}: ${v.pattern} - ${v.recommendation}`).join('\n')}

## Summary

Total Issues Found:
- High: ${slitherResults.high.length}
- Medium: ${slitherResults.medium.length}
- Low: ${slitherResults.low.length}
- Informational: ${slitherResults.informational.length}

## Recommendations

1. Address all high severity issues before deployment
2. Review and fix medium severity issues
3. Consider low severity issues for improved security
4. Run this scan regularly during development
5. Get a professional third-party audit before mainnet deployment
`;

            // Save report
            const reportPath = path.join(this.outputPath, "vulnerability-scan-report.md");
            fs.writeFileSync(reportPath, report);
            console.log(`‚úÖ Report saved to: ${reportPath}`);

            // Check for critical issues
            if (slitherResults.high.length > 0) {
                console.error(`\n‚ö†Ô∏è  WARNING: ${slitherResults.high.length} high severity issues found!`);
            }

        } catch (error) {
            console.error("‚ùå Failed to generate report:", error);
            throw error;
        }
    }

    /**
     * Find all Solidity files recursively
     */
    private findSolidityFiles(dir: string): string[] {
        const files: string[] = [];
        
        const items = fs.readdirSync(dir);
        for (const item of items) {
            const fullPath = path.join(dir, item);
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory() && !item.startsWith('.')) {
                files.push(...this.findSolidityFiles(fullPath));
            } else if (item.endsWith('.sol')) {
                files.push(fullPath);
            }
        }
        
        return files;
    }
}

// Type definitions
interface SlitherResults {
    high: SecurityIssue[];
    medium: SecurityIssue[];
    low: SecurityIssue[];
    informational: SecurityIssue[];
    optimization: SecurityIssue[];
}

interface SecurityIssue {
    check: string;
    impact: string;
    confidence: string;
    description: string;
    elements: any[];
}

interface CustomVulnerabilities {
    unboundedLoops: VulnerabilityDetail[];
    externalCalls: VulnerabilityDetail[];
    assemblyUsage: VulnerabilityDetail[];
    deprecatedFunctions: VulnerabilityDetail[];
    suspiciousPatterns: VulnerabilityDetail[];
}

interface VulnerabilityDetail {
    file: string;
    pattern: string;
    recommendation: string;
}

// Execute scanner if run directly
if (require.main === module) {
    const scanner = new VulnerabilityScanner();
    scanner.generateReport()
        .then(() => {
            console.log("\n‚úÖ Vulnerability scan completed");
            process.exit(0);
        })
        .catch(error => {
            console.error("\n‚ùå Vulnerability scan failed:", error);
            process.exit(1);
        });
}

export { VulnerabilityScanner, SlitherResults, CustomVulnerabilities };