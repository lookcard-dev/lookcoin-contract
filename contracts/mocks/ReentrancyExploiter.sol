// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "../LookCoin.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";

/**
 * @title ReentrancyExploiter
 * @dev Contract that demonstrates how reentrancy guards work
 * Since LookCoin's mint/burn don't have callbacks, we create a separate
 * function with a callback to show the guard in action
 */
contract ReentrancyExploiter is ReentrancyGuardUpgradeable {
    LookCoin public lookCoin;
    
    uint256 public callbackCount;
    address public callbackContract;
    bool public attackEnabled;
    
    event CallbackExecuted(uint256 count);
    event ReentrancyBlocked(string reason);
    
    function initialize(address _lookCoin) public initializer {
        __ReentrancyGuard_init();
        lookCoin = LookCoin(_lookCoin);
    }
    
    /**
     * @dev Function with callback that can be exploited for reentrancy
     */
    function mintWithCallback(address to, uint256 amount) external nonReentrant {
        // Increment counter
        callbackCount++;
        
        // If callback is set, call it (this is where reentrancy could occur)
        if (callbackContract != address(0)) {
            ICallback(callbackContract).onMintCallback(msg.sender, to, amount);
        }
        
        // Mint tokens
        lookCoin.mint(to, amount);
        
        emit CallbackExecuted(callbackCount);
    }
    
    /**
     * @dev Function without reentrancy guard (vulnerable)
     */
    function mintWithCallbackVulnerable(address to, uint256 amount) external {
        // Increment counter
        callbackCount++;
        
        // If callback is set, call it (this is where reentrancy WILL occur)
        if (callbackContract != address(0)) {
            ICallback(callbackContract).onMintCallback(msg.sender, to, amount);
        }
        
        // Mint tokens
        lookCoin.mint(to, amount);
        
        emit CallbackExecuted(callbackCount);
    }
    
    /**
     * @dev Set the callback contract
     */
    function setCallbackContract(address _callback) external {
        callbackContract = _callback;
    }
    
    /**
     * @dev Grant minter role to this contract
     */
    function requestMinterRole() external {
        // Request minter role from LookCoin admin
    }
}

/**
 * @title AttackerCallback
 * @dev Malicious callback that attempts reentrancy
 */
contract AttackerCallback {
    ReentrancyExploiter public exploiter;
    uint256 public reentrancyAttempts;
    bool public attackEnabled;
    
    event ReentrancyAttempted(bool success);
    
    constructor(address _exploiter) {
        exploiter = ReentrancyExploiter(_exploiter);
    }
    
    function enableAttack() external {
        attackEnabled = true;
        reentrancyAttempts = 0;
    }
    
    function onMintCallback(address operator, address to, uint256 amount) external {
        if (attackEnabled && reentrancyAttempts == 0) {
            reentrancyAttempts++;
            
            // Try to reenter the guarded function
            try exploiter.mintWithCallback(to, amount) {
                // This should not happen with nonReentrant
                emit ReentrancyAttempted(true);
            } catch {
                // This is expected with nonReentrant
                emit ReentrancyAttempted(false);
            }
            
            // Also try the vulnerable version
            try exploiter.mintWithCallbackVulnerable(to, amount) {
                // This WILL succeed on vulnerable function
                emit ReentrancyAttempted(true);
            } catch {
                emit ReentrancyAttempted(false);
            }
        }
    }
}

interface ICallback {
    function onMintCallback(address operator, address to, uint256 amount) external;
}